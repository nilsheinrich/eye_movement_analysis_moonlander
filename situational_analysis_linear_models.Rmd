---
title: "situational_analysis_linear_models"
author: "Nils Wendel Heinrich"
date: '2023-08-16'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, include=FALSE}
library(tidyverse)
library(lme4)
library(lmerTest)
library(sjPlot)
library(ggplot2)
library(fitdistrplus)
```

```{r data, include=FALSE}

setwd('/Users/heinrich/Projects/eye_movement_analysis_moonlander/')

data_fixations <- read_csv("eye_data/situational_analysis_data/situational_fixations_data.csv")
data_saccades <- read_csv("eye_data/situational_analysis_data/situational_saccades_data.csv")

```

# Predicting fixations

Variables of interest are:
- *fixation_duration*
- *distSpaceship_fix_rest*
- *distClosestObstacle_fix_explore*
whereby we have to differentiate between **resting** and **exploring** fixations.

We will start by subsetting the data into two different data sets. For this we will filter out fixations of 0 duration. These may occur due to the eye tracker flagging only a single frame as fixation.
```{r rest_vs_explore, include=TRUE}

# only considering fixations with duration > 0:
data_fixations <- data_fixations[data_fixations$fixation_duration > 0, ]

exploring_fixations <- data_fixations[data_fixations$exploring_fixation == TRUE, ]
resting_fixations <- data_fixations[data_fixations$exploring_fixation == FALSE, ]

```

## Resting fixations - Fixation duration

```{r check_fixDur_rest_fit, include=TRUE}

hist(resting_fixations$fixation_duration, breaks=200)

fit.gamma <- fitdist(resting_fixations$fixation_duration, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

fixDur_rest_null <- glmer(fixation_duration ~ 1 + (1|code), data=resting_fixations, family = Gamma)
summary(fixDur_rest_null)

```

```{r ICC_fixDur_rest, include=TRUE}

ICC_fixDur_rest <- 36.396 / (36.396 + 2.252)
ICC_fixDur_rest

```

```{r fixation_duration, include=TRUE}

pred_fixDur_rest <- glmer(fixation_duration ~ success + (1|code), data=resting_fixations, family = Gamma)

pred_fixDur_rest.slope <- glmer(fixation_duration ~ success + (1+success|code), data=resting_fixations, family = Gamma)  # isSingular

anova(pred_fixDur_rest, pred_fixDur_rest.slope)

summary(pred_fixDur_rest)

```

## Resting fixations - Distance to spaceship

We will assume a normal distribution for this predicted variable.
```{r check_distSpaceship_fit, include=TRUE}

hist(resting_fixations$distSpaceship_fix_rest, breaks=200)

fit.gauss <- fitdist(resting_fixations$distSpaceship_fix_rest, distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

distSpaceship_null <- lmer(distSpaceship_fix_rest ~ 1 + (1|code), data=resting_fixations, REML=FALSE)
summary(distSpaceship_null)

```

```{r ICC_distSpaceship, include=TRUE}

ICC_distSpaceship <- 0.08819 / (0.08819 + 0.78057)
ICC_distSpaceship

```

```{r fixation_duration, include=TRUE}

pred_distSpaceship <- lmer(distSpaceship_fix_rest ~ success + (1|code), data=resting_fixations, REML=FALSE)

pred_distSpaceship.slope <- lmer(distSpaceship_fix_rest ~ success + (1+success|code), data=resting_fixations, REML=FALSE)

anova(pred_distSpaceship, pred_distSpaceship.slope)

summary(pred_distSpaceship)

```

Discussing the results: We find a significant fixed effect for success on the distance to the spaceship in resting fixations. This means that in successful runs, participants allocated their resting fixations further away from the spaceship compared to crash runs.  

## Exploring fixations - Fixation duration

```{r check_distSpaceship_fit, include=TRUE}

hist(exploring_fixations$fixation_duration, breaks=200)

fit.gamma <- fitdist(exploring_fixations$fixation_duration, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

fixDur_explore_null <- lmer(fixation_duration ~ 1 + (1|code), data=exploring_fixations, REML=FALSE)
summary(fixDur_explore_null)

```

```{r ICC_fixDur_explore, include=TRUE}

ICC_fixDur_explore <- 0.03625 / (0.03625 + 0.08348)
ICC_fixDur_explore

```

```{r fixation_duration, include=TRUE}

pred_fixDur_explore <- glmer(fixation_duration ~ success + (1|code), data=exploring_fixations, family = Gamma)

pred_fixDur_explore.slope <- glmer(fixation_duration ~ success + (1+success|code), data=exploring_fixations, family = Gamma)

anova(pred_fixDur_explore, pred_fixDur_explore.slope)

summary(pred_fixDur_explore)

```

## Exploring fixations - Distance to closest obstacle

Here we assume a normally distributed predicted variable.
```{r check_distObstacle_fit, include=TRUE}

hist(exploring_fixations$distClosestObstacle_fix_explore, breaks=200)
# this looks like a truncated normal distribution

fit.gamma <- fitdist(exploring_fixations$distClosestObstacle_fix_explore, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

#gauss: AIC:  23729.99   BIC:  23740.75
#gamma: AIC:  22488.64   BIC:  22499.4 


```

```{r random_effects, include=TRUE}

distObstacle_null <- glmer(distClosestObstacle_fix_explore ~ 1 + (1|code), data=exploring_fixations, family = Gamma)
summary(distObstacle_null)

# Warning: Model failed to converge with max|grad| = 0.0778515 (tol = 0.002, component 1)Warning: Model is nearly unidentifiable: very large eigenvalue
# - Rescale variables?

```

```{r ICC_distObstacle, include=TRUE}

ICC_distObstacle <- 0.0003713 / (0.0003713 + 0.1456821)
ICC_distObstacle

```

Nearly no variance in the predicted variable is explained by participant code. We will therefore omit including code as random effect.

```{r distClosestObstacle_fix_explore, include=TRUE}

pred_distObstacle <- glm(distClosestObstacle_fix_explore ~ success, data=exploring_fixations, family = Gamma)

summary(pred_distObstacle)

```

Discussing the results: We find a significant fixed effect for success on distance to the closest obstacle in exploring fixations. This means that in successful runs, the participant allocated their exploring fixations further away from obstacles compared to crash runs.

# Predicting saccades

Variables of interest are:
- *saccade_amplitude*
- *distClosestObstacle_sacc_progress*
- *distClosestObstacle_sacc_regress*
whereby we have to differentiate between **progressive** and **regressive** saccades

We will start to subset the data into two different data sets. For this we will filter out saccades of 0 amplitude These may occur due to the eye tracker flagging only a single frame as saccade.
```{r progress_vs_regress, include=TRUE}

# only considering fixations with duration > 0:
data_saccades <- data_saccades[data_saccades$saccade_amplitude > 0, ]

progressive_saccades <- data_saccades[data_saccades$progressive_saccade == TRUE, ]
regressive_saccades <- data_saccades[data_saccades$progressive_saccade == FALSE, ]

```

## Progressive saccades - Saccade amplitude

```{r check_saccAmp_progress_fit, include=TRUE}

hist(progressive_saccades$saccade_amplitude, breaks=200)

fit.gamma <- fitdist(progressive_saccades$saccade_amplitude, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

saccAmp_progress_null <- glmer(saccade_amplitude ~ 1 + (1|code), data=progressive_saccades, family = Gamma)
summary(saccAmp_progress_null)

```

```{r ICC_saccAmp_progress, include=TRUE}

ICC_saccAmp_progress <- 0.1751 / (0.1751 + 1.8584)
ICC_saccAmp_progress

```

```{r saccade_amplitude_progress, include=TRUE}

pred_saccAmp_progress <- glmer(saccade_amplitude ~ success + (1|code), data=progressive_saccades, family = Gamma)

pred_saccAmp_progress.slope <- glmer(saccade_amplitude ~ success + (1+success|code), data=progressive_saccades, family = Gamma)

anova(pred_saccAmp_progress, pred_saccAmp_progress.slope)

summary(pred_saccAmp_progress)

```

## Progressive saccades - Distance to closest obstacle

```{r check_distObs_progress_fit, include=TRUE}

hist(progressive_saccades$distClosestObstacle_sacc_progress, breaks=200)

# maybe log transform distClosestObstacle columns?

# we cannot ensure that distances won't be =0 (not allowed in gamma). We therefore assume a normal distribution
fit.gauss <- fitdist(c(na.exclude(progressive_saccades$distClosestObstacle_sacc_progress)), distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r log_transform_distObs_progress, include=TRUE}

progressive_saccades$distClosestObstacle_sacc_progress.log <- log10(progressive_saccades$distClosestObstacle_sacc_progress)

hist(progressive_saccades$distClosestObstacle_sacc_progress.log, breaks=200)

# we cannot ensure that distances won't be =0 (not allowed in gamma). We therefore assume a normal distribution
fit.gauss <- fitdist(c(na.exclude(progressive_saccades$distClosestObstacle_sacc_progress.log)), distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

distClosestObstacle_sacc_progress_null <- lmer(distClosestObstacle_sacc_progress.log ~ 1 + (1|code), data=progressive_saccades, REML=FALSE)
summary(distClosestObstacle_sacc_progress_null)

```

```{r ICC_distObs_progress, include=TRUE}

ICC_distObs_progress <- 64.56 / (64.56 + 183.31)
ICC_distObs_progress <- 0.06539 / (0.06539 + 0.18318)
ICC_distObs_progress

```

```{r distObstacle_progress, include=TRUE}

pred_distObstacle_progress <- lmer(distClosestObstacle_sacc_progress.log ~ success + (1|code), data=progressive_saccades, REML=FALSE)

pred_distObstacle_progress.slope <- lmer(distClosestObstacle_sacc_progress.log ~ success + (1+success|code), data=progressive_saccades, REML=FALSE)

anova(pred_distObstacle_progress, pred_distObstacle_progress.slope)

summary(pred_distObstacle_progress.slope)
# we loose the fixed effect for success when including the random slope effect for code on success, but the random slope model is the one with the better AIC & BIC

```

## Regressive saccades - Saccade amplitude

```{r check_saccAmp_regress_fit, include=TRUE}

hist(regressive_saccades$saccade_amplitude, breaks=200)

fit.gamma <- fitdist(regressive_saccades$saccade_amplitude, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

saccAmp_regress_null <- glmer(saccade_amplitude ~ 1 + (1|code), data=regressive_saccades, family = Gamma)
summary(saccAmp_regress_null)

```

```{r ICC_saccAmp_regress, include=TRUE}

ICC_saccAmp_regress <- 0.4938 / (0.4938 + 2.2681)
ICC_saccAmp_regress

```

```{r saccade_amplitude_regress, include=TRUE}

pred_saccAmp_regress <- glmer(saccade_amplitude ~ success + (1|code), data=regressive_saccades, family = Gamma)

pred_saccAmp_regress.slope <- glmer(saccade_amplitude ~ success + (1+success|code), data=regressive_saccades, family = Gamma)

anova(pred_saccAmp_regress, pred_saccAmp_regress.slope) # not significantly different 

summary(pred_saccAmp_regress)

```

## Regressive saccades - Distance to closest obstacle

```{r check_distObs_fit, include=TRUE}

hist(regressive_saccades$distClosestObstacle_sacc_regress, breaks=200)

# we cannot ensure that distances won't be =0. We therefore assume a normal distribution
fit.gauss <- fitdist(c(na.exclude(regressive_saccades$distClosestObstacle_sacc_regress)), distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r log_transform_distObs, include=TRUE}

regressive_saccades$distClosestObstacle_sacc_regress.log <- log10(regressive_saccades$distClosestObstacle_sacc_regress)

hist(regressive_saccades$distClosestObstacle_sacc_regress.log, breaks=200)

# we cannot ensure that distances won't be =0. We therefore assume a normal distribution
fit.gauss <- fitdist(c(na.exclude(regressive_saccades$distClosestObstacle_sacc_regress.log)), distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

# no transfrom: AIC:  4196.973   BIC:  4205.275 
# log transform: AIC:  871.9101   BIC:  880.2113

```

```{r random_effects, include=TRUE}

distClosestObstacle_sacc_regress_null <- lmer(distClosestObstacle_sacc_regress.log ~ 1 + (1|code), data=regressive_saccades, REML=FALSE)
summary(distClosestObstacle_sacc_regress_null)

```

```{r ICC_distObs_regress, include=TRUE}

ICC_distObs_regress <- 0.1480 / (0.1480 + 0.1999)
ICC_distObs_regress

```

```{r distObstacle_regress, include=TRUE}

pred_distObstacle_regress <- lmer(distClosestObstacle_sacc_regress.log ~ success + (1|code), data=regressive_saccades, REML=FALSE)

pred_distObstacle_regress.slope <- lmer(distClosestObstacle_sacc_regress.log ~ success + (1+success|code), data=regressive_saccades, REML=FALSE)

anova(pred_distObstacle_regress, pred_distObstacle_regress.slope)

# again, we loose the fixed effect for success when including the random slope effect for code on success, but the random slope model is the one with the better AIC & BIC
summary(pred_distObstacle_regress.slope)

```
