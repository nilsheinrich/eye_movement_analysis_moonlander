---
title: "situational_analysis_linear_models"
author: "Nils Wendel Heinrich"
date: '2023-08-16'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, include=FALSE}
library(tidyverse)
library(lme4)
library(lmerTest)
library(sjPlot)
library(ggplot2)
library(fitdistrplus)
```

```{r data, include=FALSE}

setwd('/Users/heinrich/Projects/eye_movement_analysis_moonlander/')

data_fixations <- read_csv("eye_data/situational_analysis_data/situational_fixations_data.csv")
data_saccades <- read_csv("eye_data/situational_analysis_data/situational_saccades_data.csv")

```

# Predicting fixations

Variables of interest are:
- *fixation_duration*
- *distSpaceship_fix_rest*
- *distClosestObstacle_fix_explore*
whereby we have to differentiate between **resting** and **exploring** fixations.

We will start by subsetting the data into two different data sets. For this we will filter out fixations of 0 duration. These may occur due to the eye tracker flagging only a single frame as fixation.
```{r rest_vs_explore, include=TRUE}

# only considering fixations with duration > 0:
data_fixations <- data_fixations[data_fixations$fixation_duration > 0, ]

exploring_fixations <- data_fixations[data_fixations$exploring_fixation == TRUE, ]
resting_fixations <- data_fixations[data_fixations$exploring_fixation == FALSE, ]

```

## Resting fixations - Fixation duration

```{r check_fixDur_rest_fit, include=TRUE}

hist(resting_fixations$fixation_duration, breaks=200)

hist(log(resting_fixations$fixation_duration), breaks=200)

resting_fixations$fixation_duration.log <- log(resting_fixations$fixation_duration)

fit.gauss <- fitdist(resting_fixations$fixation_duration.log, distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

#Gamma: AIC:  -589.6791   BIC:  -579.7603
#log-transformed normal: AIC:  4363.395   BIC:  4373.313

```

```{r random_effects, include=TRUE}

fixDur_rest_null <- glmer(fixation_duration ~ 1 + (1|code), data=resting_fixations, family = Gamma)

fixDur_rest_null <- lmer(fixation_duration.log ~ 1 + (1|code), data=resting_fixations, REML = FALSE)

summary(fixDur_rest_null)

```

```{r ICC_fixDur_rest, include=TRUE}

ICC_fixDur_rest <- 34.068 / (34.068 + 2.193)

ICC_fixDur_rest <- 1.251 / (1.251 + 1.662)

ICC_fixDur_rest

```

```{r fixation_duration, include=TRUE}

pred_fixDur_rest <- glmer(fixation_duration ~ success + (1|code), data=resting_fixations, family = Gamma)

pred_fixDur_rest.slope <- glmer(fixation_duration ~ success + (1+success|code), data=resting_fixations, family = Gamma)  # isSingular

# log normal
pred_fixDur_rest <- lmer(fixation_duration ~ success + (1|code), data=resting_fixations, REML = FALSE)

pred_fixDur_rest.slope <- lmer(fixation_duration ~ success + (1+success|code), data=resting_fixations, REML = FALSE)

anova(pred_fixDur_rest, pred_fixDur_rest.slope)

summary(pred_fixDur_rest.slope)

```

```{r eval=TRUE, cache=TRUE}
# fixed effects
fixef(pred_fixDur_rest.slope)

# bootstrap
confint(pred_fixDur_rest.slope, nsim=100, parm=c("successTRUE"), method="boot")

```

## Resting fixations - Distance to spaceship

We will assume a normal distribution for this predicted variable.
```{r check_distSpaceship_fit, include=TRUE}

hist(resting_fixations$distSpaceship_fix_rest, breaks=200)

fit.gauss <- fitdist(resting_fixations$distSpaceship_fix_rest, distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

distSpaceship_null <- lmer(distSpaceship_fix_rest ~ 1 + (1|code), data=resting_fixations, REML=FALSE)
summary(distSpaceship_null)

```

```{r ICC_distSpaceship, include=TRUE}

ICC_distSpaceship <- 0.08552 / (0.08552 + 0.77587)
ICC_distSpaceship

```

```{r fixation_duration, include=TRUE}

pred_distSpaceship <- lmer(distSpaceship_fix_rest ~ success + (1|code), data=resting_fixations, REML=FALSE)

pred_distSpaceship.slope <- lmer(distSpaceship_fix_rest ~ success + (1+success|code), data=resting_fixations, REML=FALSE)

anova(pred_distSpaceship, pred_distSpaceship.slope)

summary(pred_distSpaceship)

```

Discussing the results: We find a significant fixed effect for success on the distance to the spaceship in resting fixations. This means that in successful runs, participants allocated their resting fixations further away from the spaceship compared to crash runs.  

## Exploring fixations - Fixation duration

```{r check_distSpaceship_fit, include=TRUE}

hist(exploring_fixations$fixation_duration, breaks=200)

hist(log(exploring_fixations$fixation_duration), breaks=200)

exploring_fixations$fixation_duration.log <- log(exploring_fixations$fixation_duration)

fit.gauss <- fitdist(exploring_fixations$fixation_duration.log, distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

fixDur_explore_null <- glmer(fixation_duration ~ 1 + (1|code), data=exploring_fixations, family = Gamma)

fixDur_explore_null <- lmer(fixation_duration ~ 1 + (1|code), data=exploring_fixations, REML = FALSE)

summary(fixDur_explore_null)

```

```{r ICC_fixDur_explore, include=TRUE}

ICC_fixDur_explore <- 40.041 / (40.041 + 2.095)

ICC_fixDur_explore <- 0.03587 / (0.03587 + 0.08455)

ICC_fixDur_explore

```

```{r fixation_duration, include=TRUE}

#pred_fixDur_explore <- glmer(fixation_duration ~ success + (1|code), data=exploring_fixations, family = Gamma)

pred_fixDur_explore <- lmer(fixation_duration ~ success + (1|code), data=exploring_fixations, REML = FALSE)

#pred_fixDur_explore.slope <- glmer(fixation_duration ~ success + (1+success|code), data=exploring_fixations, family = Gamma)

pred_fixDur_explore.slope <- lmer(fixation_duration ~ success + (1+success|code), data=exploring_fixations, REML = FALSE)

anova(pred_fixDur_explore, pred_fixDur_explore.slope)

summary(pred_fixDur_explore.slope)

```

## Exploring fixations - Distance to closest obstacle

```{r check_distObstacle_fit, include=TRUE}

hist(exploring_fixations$distClosestObstacle_fix_explore, breaks=200)
# this looks like a truncated normal distribution

hist(log(exploring_fixations$distClosestObstacle_fix_explore), breaks=200)

exploring_fixations$distClosestObstacle_fix_explore.log <- log(exploring_fixations$distClosestObstacle_fix_explore)

fit.gauss <- fitdist(exploring_fixations$distClosestObstacle_fix_explore.log, distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

#gauss: AIC:  23729.99   BIC:  23740.75
#gamma: AIC:  22488.64   BIC:  22499.4 


```

```{r random_effects, include=TRUE}

#distObstacle_null <- glmer(distClosestObstacle_fix_explore ~ 1 + (1|code), data=exploring_fixations, family = Gamma)

distObstacle_null <- lmer(distClosestObstacle_fix_explore.log ~ 1 + (1|code), data=exploring_fixations, REML = FALSE)

summary(distObstacle_null)

# glmer: Warning: Model failed to converge with max|grad| = 0.0344018 (tol = 0.002, component 1)Warning: Model is nearly unidentifiable: very large eigenvalue
# - Rescale variables?

```

```{r ICC_distObstacle, include=TRUE}

ICC_distObstacle <- 0.0003747 / (0.0003747 + 0.1436312)

ICC_distObstacle <- 0.08692 / (0.08692 + 0.14374)

ICC_distObstacle

```

Nearly no variance in the predicted variable is explained by participant code. We will therefore omit including code as random effect.

```{r distClosestObstacle_fix_explore, include=TRUE}

#pred_distObstacle <- glm(distClosestObstacle_fix_explore ~ success, data=exploring_fixations, family = Gamma)

pred_distObstacle <- lmer(distClosestObstacle_fix_explore.log ~ success + (1|code), data=exploring_fixations, REML = FALSE)

pred_distObstacle.slope <- lmer(distClosestObstacle_fix_explore.log ~ success + (1+success|code), data=exploring_fixations, REML = FALSE)

anova(pred_distObstacle, pred_distObstacle.slope)

summary(pred_distObstacle.slope)

```

Discussing the results: ...

# Predicting saccades

Variables of interest are:
- *saccade_amplitude*
- *distClosestObstacle_sacc_progress*
- *distClosestObstacle_sacc_regress*
whereby we have to differentiate between **progressive** and **regressive** saccades

We will start to subset the data into two different data sets. For this we will filter out saccades of 0 amplitude These may occur due to the eye tracker flagging only a single frame as saccade.
```{r progress_vs_regress, include=TRUE}

# only considering fixations with duration > 0:
data_saccades <- data_saccades[data_saccades$saccade_amplitude > 0, ]

progressive_saccades <- data_saccades[data_saccades$progressive_saccade == TRUE, ]
regressive_saccades <- data_saccades[data_saccades$progressive_saccade == FALSE, ]

```

## Progressive saccades - Saccade amplitude

```{r check_saccAmp_progress_fit, include=TRUE}

#hist(progressive_saccades$saccade_amplitude), breaks=200)

#fit.gamma <- fitdist(progressive_saccades$saccade_amplitude, distr = "gamma", method = "mme")
#summary(fit.gamma)
#plot(fit.gamma)

progressive_saccades$saccade_amplitude.log <- log(progressive_saccades$saccade_amplitude)

hist(log(progressive_saccades$saccade_amplitude), breaks=200)

fit.gauss <- fitdist(progressive_saccades$saccade_amplitude.log, distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

#saccAmp_progress_null <- glmer(saccade_amplitude ~ 1 + (1|code), data=progressive_saccades, family = Gamma)

# with log normal
saccAmp_progress_null <- lmer(saccade_amplitude.log ~ 1 + (1|code), data=progressive_saccades, REML = FALSE)

summary(saccAmp_progress_null)

```

```{r ICC_saccAmp_progress, include=TRUE}

#ICC_saccAmp_progress <- 0.1775 / (0.1775 + 1.8439)

# log normal
ICC_saccAmp_progress <- 0.3076 / (0.3076 + 2.1804)

ICC_saccAmp_progress

```

```{r saccade_amplitude_progress, include=TRUE}

pred_saccAmp_progress <- glmer(saccade_amplitude ~ success + (1|code), data=progressive_saccades, family = Gamma)

#pred_saccAmp_progress.slope <- glmer(saccade_amplitude ~ success + (1+success|code), data=progressive_saccades, family = Gamma) # Error: PIRLS loop resulted in NaN value

# log normal
pred_saccAmp_progress <- lmer(saccade_amplitude.log ~ success + (1|code), data=progressive_saccades, REML = FALSE)

pred_saccAmp_progress.slope <- lmer(saccade_amplitude.log ~ success + (1+success|code), data=progressive_saccades, REML = FALSE)
#summary(pred_saccAmp_progress.slope)

anova(pred_saccAmp_progress, pred_saccAmp_progress.slope)

summary(pred_saccAmp_progress)

```

## Progressive saccades - Distance to closest obstacle

```{r check_distObs_progress_fit, include=TRUE}

hist(progressive_saccades$distClosestObstacle_sacc_progress, breaks=200)

# maybe log transform distClosestObstacle columns?
progressive_saccades$distClosestObstacle_sacc_progress.log <- log(progressive_saccades$distClosestObstacle_sacc_progress)

# we cannot ensure that distances won't be =0 (not allowed in gamma). We therefore assume a normal distribution
fit.gauss <- fitdist(c(na.exclude(progressive_saccades$distClosestObstacle_sacc_progress.log)), distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

distClosestObstacle_sacc_progress_null <- lmer(distClosestObstacle_sacc_progress.log ~ 1 + (1|code), data=progressive_saccades, REML=FALSE)
summary(distClosestObstacle_sacc_progress_null)

```

```{r ICC_distObs_progress, include=TRUE}

#ICC_distObs_progress <- 64.56 / (64.56 + 183.31)
ICC_distObs_progress <- 0.2661 / (0.2661 + 0.8950)
ICC_distObs_progress

```

```{r distObstacle_progress, include=TRUE}

pred_distObstacle_progress <- lmer(distClosestObstacle_sacc_progress.log ~ success + (1|code), data=progressive_saccades, REML=FALSE)

pred_distObstacle_progress.slope <- lmer(distClosestObstacle_sacc_progress.log ~ success + (1+success|code), data=progressive_saccades, REML=FALSE)

anova(pred_distObstacle_progress, pred_distObstacle_progress.slope)

summary(pred_distObstacle_progress.slope)
# we loose the fixed effect for success when including the random slope effect for code on success, but the random slope model is the one with the better AIC & BIC

```

## Regressive saccades - Saccade amplitude

```{r check_saccAmp_regress_fit, include=TRUE}

hist(regressive_saccades$saccade_amplitude, breaks=200)

hist(log(regressive_saccades$saccade_amplitude), breaks=200)

regressive_saccades$saccade_amplitude.log <- log(regressive_saccades$saccade_amplitude)

fit.gauss <- fitdist(regressive_saccades$saccade_amplitude.log, distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

saccAmp_regress_null <- lmer(saccade_amplitude ~ 1 + (1|code), data=regressive_saccades, REML = FALSE)
summary(saccAmp_regress_null)

```

```{r ICC_saccAmp_regress, include=TRUE}

#ICC_saccAmp_regress <- 0.4938 / (0.4938 + 2.2681)
ICC_saccAmp_regress <- 1.434 / (1.434 + 26.672)
ICC_saccAmp_regress

```

```{r saccade_amplitude_regress, include=TRUE}

pred_saccAmp_regress <- lmer(saccade_amplitude ~ success + (1|code), data=regressive_saccades, REML = FALSE)

pred_saccAmp_regress.slope <- lmer(saccade_amplitude ~ success + (1+success|code), data=regressive_saccades, REML = FALSE) # isSingular

anova(pred_saccAmp_regress, pred_saccAmp_regress.slope) # not significantly different 

summary(pred_saccAmp_regress)

```

## Regressive saccades - Distance to closest obstacle

```{r check_distObs_fit, include=TRUE}

hist(regressive_saccades$distClosestObstacle_sacc_regress, breaks=200)

hist(log(regressive_saccades$distClosestObstacle_sacc_regress), breaks=200)

regressive_saccades$distClosestObstacle_sacc_regress.log <- log(regressive_saccades$distClosestObstacle_sacc_regress)

# we cannot ensure that distances won't be =0. We therefore assume a normal distribution
fit.gauss <- fitdist(c(na.exclude(regressive_saccades$distClosestObstacle_sacc_regress.log)), distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

distClosestObstacle_sacc_regress_null <- lmer(distClosestObstacle_sacc_regress.log ~ 1 + (1|code), data=regressive_saccades, REML=FALSE)
summary(distClosestObstacle_sacc_regress_null)

```

```{r ICC_distObs_regress, include=TRUE}

ICC_distObs_regress <- 0.7747 / (0.7747 + 1.0511)
ICC_distObs_regress

```

```{r distObstacle_regress, include=TRUE}

pred_distObstacle_regress <- lmer(distClosestObstacle_sacc_regress.log ~ success + (1|code), data=regressive_saccades, REML=FALSE)

pred_distObstacle_regress.slope <- lmer(distClosestObstacle_sacc_regress.log ~ success + (1+success|code), data=regressive_saccades, REML=FALSE)

anova(pred_distObstacle_regress, pred_distObstacle_regress.slope)

# again, we loose the fixed effect for success when including the random slope effect for code on success, but the random slope model is the one with the better AIC & BIC
summary(pred_distObstacle_regress.slope)

```
