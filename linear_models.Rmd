---
title: "linear_modeling_moonlander_eye_data"
author: "Nils Wendel Heinrich"
date: '2023-02-17'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, include=FALSE}
library(tidyverse)
library(lme4)
library(lmerTest)
library(sjPlot)
library(ggplot2)
library(fitdistrplus)
```


```{r eye_data, include=FALSE}

setwd('/Users/heinrich/Projects/eye_movement_analysis_moonlander/')

data_fixations <- read_csv("eye_data/experimental_eye_data_fixations.csv")
data_saccades <- read_csv("eye_data/experimental_eye_data_saccades.csv")

```
We have data from 26 participants. Exclusion took place and will have to be specified here...

```{r edit_data, include=FALSE}

# Most likely we won't use level difficulty as fixed effect. But we will nevertheless relevel it.

# fixations
data_fixations <- data_fixations %>%
  mutate(level_difficulty = case_when(
    (level == 1 | level == 2) ~ "easy",
    (level == 3 | level == 4) ~ "medium",
    (level == 5 | level == 6) ~ "hard",
    ))
data_fixations$level_difficulty <- as.factor(data_fixations$level_difficulty)
data_fixations <- within(data_fixations, level_difficulty <- relevel(level_difficulty, ref = "easy"))

# saccades
data_saccades <- data_saccades %>%
  mutate(level_difficulty = case_when(
    (level == 1 | level == 2) ~ "easy",
    (level == 3 | level == 4) ~ "medium",
    (level == 5 | level == 6) ~ "hard",
    ))
data_saccades$level_difficulty <- as.factor(data_saccades$level_difficulty)
data_saccades <- within(data_saccades, level_difficulty <- relevel(level_difficulty, ref = "easy"))

```

# Predicting fixations

Fixations may have served various functions. We will try to account for it and differentiate between resting and exploring fixations. 
```{r splitting_fixations, include=TRUE}

# only considering fixations with duration > 0:
data_fixations <- data_fixations[data_fixations$fixation_duration > 0, ]
# The eye tracker might have flagged single frames as fixations. These would have lasted no time and we will simply filter them out.

# distinguishing exploring and resting fixations
#x_sp = 972
#y_sp = 288

# 4° is half of the span of the parafovea. We will use that as the threshold (keeping the spaceship clearly visible vs. not)
#threshold = 4

#data_fixations$distance_to_spaceship <- sqrt((data_fixations$converging_eye_x_adjusted - x_sp)**2 + (data_fixations$converging_eye_y_adjusted - y_sp)**2)

exploring_fixations <- data_fixations[data_fixations$exploring_fixation == 1, ]
resting_fixations <- data_fixations[data_fixations$exploring_fixation == 0, ]

```

## Resting fixations - Fixation duration

```{r check_fixDur_rest_fit, include=TRUE}

hist(resting_fixations$fixation_duration, breaks=200)

fit.gamma <- fitdist(resting_fixations$fixation_duration, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

fixDur_rest_null <- lmer(fixation_duration ~ 1 + (1|ID), data=resting_fixations, REML=FALSE)
summary(fixDur_rest_null)

```

```{r ICC_fixDur_rest, include=TRUE}

ICC_fixDur_rest <- 0.02655 / (0.02655 + 0.10495)
ICC_fixDur_rest

```

```{r fixation_duration_rest, include=TRUE}

pred_fixDur_rest <- glmer(fixation_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID), data=resting_fixations, family = Gamma)

pred_fixDur_rest.slope <- glmer(fixation_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_obstacles|ID), data=resting_fixations, family = Gamma)

pred_fixDur_rest.slope2 <- glmer(fixation_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_drift_tiles|ID), data=resting_fixations, family = Gamma)

anova(pred_fixDur_rest, pred_fixDur_rest.slope, pred_fixDur_rest.slope2)

summary(pred_fixDur_rest)

```

## Resting fixations - Fixation location (distance to spaceship)

```{r check_distSpaceship_rest_fit, include=TRUE}

hist(resting_fixations$distance_to_spaceship, breaks=200)

fit.gauss <- fitdist(c(na.exclude(resting_fixations$distance_to_spaceship)), distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

distSpaceship_rest_null <- lmer(distance_to_spaceship ~ 1 + (1|ID), data=resting_fixations, REML=FALSE)
summary(distSpaceship_rest_null)

```

```{r ICC_distSpaceship_rest, include=TRUE}

ICC_distSpaceship_rest <- 0.07741 / (0.07741 + 1.00426)
ICC_distSpaceship_rest

```

```{r distance_to_spaceship_rest, include=TRUE}

pred_distSpaceship_rest <- lmer(distance_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID), data=resting_fixations, REML = FALSE)

pred_distSpaceship_rest.slope <- lmer(distance_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_obstacles|ID), data=resting_fixations, REML = FALSE)

pred_distSpaceship_rest.slope2 <- lmer(distance_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_drift_tiles|ID), data=resting_fixations, REML = FALSE)  # does not converge

anova(pred_distSpaceship_rest, pred_distSpaceship_rest.slope, pred_distSpaceship_rest.slope2)

summary(pred_distSpaceship_rest.slope)

```

Discussing the results: ...

## Exploring fixations - Fixation duration

```{r check_fixDur_explore_fit, include=TRUE}

hist(exploring_fixations$fixation_duration, breaks=200)

fit.gamma <- fitdist(exploring_fixations$fixation_duration, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

fixDur_explore_null <- lmer(fixation_duration ~ 1 + (1|ID), data=exploring_fixations, REML=FALSE)
summary(fixDur_explore_null)

```

```{r ICC_fixDur_explore, include=TRUE}

ICC_fixDur_explore <- 0.02011 / (0.02011 + 0.09011)
ICC_fixDur_explore

```

```{r fixation_duration_explore, include=TRUE}

pred_fixDur_explore <- glmer(fixation_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID), data=exploring_fixations, family = Gamma)

pred_fixDur_explore.slope <- glmer(fixation_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_obstacles|ID), data=exploring_fixations, family = Gamma)

pred_fixDur_explore.slope2 <- glmer(fixation_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_drift_tiles|ID), data=exploring_fixations, family = Gamma)

pred_fixDur_explore.slope3 <- glmer(fixation_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+input_noise|ID), data=exploring_fixations, family = Gamma)

anova(pred_fixDur_explore, pred_fixDur_explore.slope, pred_fixDur_explore.slope2, pred_fixDur_explore.slope3)

summary(pred_fixDur_explore.slope3)

```

Discussing the results: ...

## Exploring fixations - Fixation location (distance to spaceship)

```{r check_distSpaceship_explore_fit, include=TRUE}

hist(exploring_fixations$distance_to_spaceship, breaks=200)

fit.gamma <- fitdist(c(na.exclude(exploring_fixations$distance_to_spaceship)), distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

distSpaceship_explore_null <- glmer(distance_to_spaceship ~ 1 + (1|ID), data=exploring_fixations, family = Gamma)
summary(distSpaceship_explore_null)

```

```{r ICC_distSpaceship_explore, include=TRUE}

ICC_distSpaceship_explore <- 0.0003975 / (0.0003975 + 0.3856651)
ICC_distSpaceship_explore

```

```{r distance_to_spaceship_explore, include=TRUE}

# ID does not explain variance in the predicted variable. We might therefore omit including it as random effect
pred_distSpaceship_explore <- glm(distance_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise, data=exploring_fixations, family = Gamma)
summary(pred_distSpaceship_explore)

# including random effects
pred_distSpaceship_explore <- lmer(distance_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID), data=exploring_fixations, REML = FALSE)
#summary(pred_distSpaceship_explore)

pred_distSpaceship_explore.slope <- lmer(distance_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_obstacles|ID), data=exploring_fixations, REML = FALSE)
#summary(pred_distSpaceship_explore.slope)

anova(pred_distSpaceship_explore, pred_distSpaceship_explore.slope)

pred_distSpaceship_explore.slope2 <- lmer(distance_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_drift_tiles|ID), data=exploring_fixations, REML = FALSE)
#summary(pred_distSpaceship_explore.slope2)

#anova(pred_distSpaceship_explore, pred_distSpaceship_explore.slope, pred_distSpaceship_explore.slope2)

#summary()

```

Discussing the results: ...

# Predicting saccades

Saccades may have served various functions. We will try to account for it and differentiate between progressive and regressive saccades. 
```{r splitting_saccades, include=TRUE}

data_saccades <- data_saccades[data_saccades$saccade_amplitude > 0 & data_saccades$saccade_amplitude < 27, ]
# filter saccades that have no saccade amplitude
data_saccades <- data_saccades[!is.na(data_saccades$saccade_amplitude),]

progressive_saccades <- data_saccades[data_saccades$saccade_direction_y < 0, ]
regressive_saccades <- data_saccades[data_saccades$saccade_direction_y > 0, ]

```

## Progressive saccades - Saccade amplitude

```{r check_saccAmp_progress_fit, include=TRUE}

hist(progressive_saccades$saccade_amplitude, breaks=200)

fit.gamma <- fitdist(progressive_saccades$saccade_amplitude, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

saccAmp_progress_null <- glmer(saccade_amplitude ~ 1 + (1|ID), data=progressive_saccades, family = Gamma)
summary(saccAmp_progress_null)

```

```{r ICC_saccAmp_progress, include=TRUE}

ICC_saccAmp_progress <- 0.008486 / (0.008486 + 1.225939)
ICC_saccAmp_progress

```

```{r saccAmp_progress, include=TRUE}

# ID does not explain variance in the predicted variable. We might therefore omit including it as random effect
pred_saccAmp_progress <- glm(saccade_amplitude ~ N_visible_obstacles * N_visible_drift_tiles + input_noise, data=progressive_saccades, family = Gamma)
summary(pred_saccAmp_progress)

```

## Progressive saccades - distance to closest obstacle

```{r check_distObs_progress_fit, include=TRUE}

hist(progressive_saccades$saccLandSite_dist_to_closestObstacle, breaks=200)

fit.gamma <- fitdist(c(na.exclude(progressive_saccades$saccLandSite_dist_to_closestObstacle)), distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

distObs_explore_null <- glmer(saccLandSite_dist_to_closestObstacle ~ 1 + (1|ID), data=progressive_saccades, family = Gamma)
summary(distObs_explore_null)

```

```{r ICC_distObs_progress, include=TRUE}

ICC_distObs_progress <- 0.00183 / (0.00183 + 0.79070)
ICC_distObs_progress

```

```{r distObs_progress, include=TRUE}

# ID does not explain variance in the predicted variable. We might therefore omit including it as random effect
pred_distObs_progress <- glm(saccLandSite_dist_to_closestObstacle ~ N_visible_obstacles * N_visible_drift_tiles + input_noise, data=progressive_saccades, family = Gamma)
summary(pred_distObs_progress)

```

## Regressive saccades - Saccade amplitude

```{r check_saccAmp_regress_fit, include=TRUE}

hist(regressive_saccades$saccade_amplitude, breaks=200)

fit.gamma <- fitdist(regressive_saccades$saccade_amplitude, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

saccAmp_regress_null <- glmer(saccade_amplitude ~ 1 + (1|ID), data=regressive_saccades, family = Gamma)
summary(saccAmp_regress_null)

```

```{r ICC_saccAmp_regress, include=TRUE}

ICC_saccAmp_regress <- 0.06734 / (0.06734 + 2.29774)
ICC_saccAmp_regress

```

```{r saccAmp_regress, include=TRUE}

# ID does not explain variance in the predicted variable. We might therefore omit including it as random effect
pred_saccAmp_regress <- glm(saccade_amplitude ~ N_visible_obstacles * N_visible_drift_tiles + input_noise, data=regressive_saccades, family = Gamma)
summary(pred_saccAmp_progress)

```

## Regressive saccades - distance to spaceship

```{r check_distSpaceship_regress_fit, include=TRUE}

hist(regressive_saccades$saccLandSite_dist_to_spaceship, breaks=200)

fit.gauss <- fitdist(regressive_saccades$saccade_amplitude, distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)

```

```{r random_effects, include=TRUE}

distSpaceship_regress_null <- lmer(saccLandSite_dist_to_spaceship ~ 1 + (1|ID), data=regressive_saccades, REML = FALSE)
summary(distSpaceship_regress_null)

```

```{r ICC_distSpaceship_regress, include=TRUE}

ICC_distSpaceship_regress <- 54.95 / (54.95 + 236.04)
ICC_distSpaceship_regress

```

```{r distSpaceship_regress, include=TRUE}

pred_distSpaceship_regress <- lmer(saccLandSite_dist_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID), data=regressive_saccades, REML = FALSE)

pred_distSpaceship_regress.slope <- lmer(saccLandSite_dist_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_obstacles|ID), data=regressive_saccades, REML = FALSE)

pred_distSpaceship_regress.slope2 <- lmer(saccLandSite_dist_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+N_visible_drift_tiles|ID), data=regressive_saccades, REML = FALSE)

pred_distSpaceship_regress.slope3 <- lmer(saccLandSite_dist_to_spaceship ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1+input_noise|ID), data=regressive_saccades, REML = FALSE)

anova(pred_distSpaceship_regress, pred_distSpaceship_regress.slope, pred_distSpaceship_regress.slope2, pred_distSpaceship_regress.slope3)

summary(pred_distSpaceship_regress.slope3)

```

# Input data - input duration

```{r input_data, include=FALSE}

input_data <- read_csv("input_data/input_data.csv")

# only considering those inputs that lasted for more than a single frame
input_data <- input_data[input_data$input_duration > 0, ]

```

```{r input_duration_input, include=TRUE}

hist(input_data$input_duration, breaks=200)

fit.gamma <- fitdist(c(na.exclude(input_data$input_duration)), distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

```

```{r random_effects, include=TRUE}

inputDur_null <- glmer(input_duration ~ 1 + (1|ID), data=input_data, family = Gamma)
summary(inputDur_null)

```

```{r ICC_inputDur, include=TRUE}

ICC_inputDur <- 1.895 / (1.895 + 2.319)
ICC_inputDur

```

```{r inputDur, include=TRUE}

inputDur <- glmer(input_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID), data=input_data, family = Gamma)

#inputDur.slope <- 

summary(inputDur)

```



























#####################################OUT#######################################

# linear modeling
```{r random_effects, include=TRUE}

# random intercept for ID

null_fixDur <- lmer(fixation_duration ~ 1 + (1|ID), data=data_fixations, REML=FALSE)
summary(null_fixDur)

null_fixLoc <- lmer(converging_eye_y ~ 1 + (1|ID), data=data_fixations, REML=FALSE)
summary(null_fixLoc)

null_saccAmp <- lmer(saccade_amplitude ~ 1 + (1|ID), data=data_saccades, REML=FALSE)
summary(null_saccAmp)

```
```{r ICCs, include=TRUE}

ICC_fixDur <- 0.02036 / (0.02036 + 0.09764)
ICC_fixDur

ICC_convergingEyeY <- 2125 / (2125 + 39658)
ICC_convergingEyeY

ICC_saccAmp <- 2.981 / (2.981 + 86.438)
ICC_saccAmp

```

# Fixations

The VPixx eye tracker might have detected fixations where there are none, resulting in a fixation duration of 0 ms. We will filter those and divide the data into fixations exploring the scene, and fixations that "rest" directly in front of the space ship.
```{r filtering, include=TRUE}

# only considering fixations with duration > 0:
data_fixations <- data_fixations[data_fixations$fixation_duration > 0, ]

# distinguishing explorative and resting fixations
#x_sp = 972
#y_sp = 288

# 4° is half of the span of the parafovea. We will use that as the threshold (keeping the spaceship clearly visible vs. not)
#threshold = 4

#data_fixations$distance_to_spaceship <- sqrt((data_fixations$converging_eye_x_adjusted - x_sp)**2 + (data_fixations$converging_eye_y_adjusted - y_sp)**2)

# subsetting exploring fixations
explorative_fixations <- data_fixations[data_fixations$exploring_fixation == 1, ]
# vs. fixations resting in front of spaceship
resting_fixations <- data_fixations[data_fixations$exploring_fixation == 0, ]

```

In the following we will investigate effects for fixation duration as well as fixation location only of the vertical axis.

### Explorative fixations
We will explore ID as random intercept effect specifically for explorative fixations first. 
```{r random_effects_for_explorative, include=TRUE}

# ID

null_1 <- lmer(fixation_duration ~ 1 + (1|ID), data=explorative_fixations, REML=FALSE)
summary(null_1)

null_2 <- lmer(converging_eye_y ~ 1 + (1|ID), data=explorative_fixations, REML=FALSE)
summary(null_2)


```

```{r ICCs_explore, include=TRUE}

ICC_fixDur_explore <- 0.02011 / (0.02011 + 0.09011)
ICC_fixDur_explore

ICC_convergingEyeY_explore <- 2209 / (2209 + 44888)
ICC_convergingEyeY_explore


```

We will definitely keep ID as random intercept effect for fixation duration. For fixation location y, there might be room to argue both ways. We will simply keep it in the model.

## fixation duration

We will first take a look at fixation duration. From experience I know that duration are not normally distributed and naturally can not have negative values. A lot of values will gather in the small x-regions and only few in the large one. We will thus explore how the data fits a gamma distribution. We will account for our distinction of explorative and resting fixations.

```{r check_fixDur_fit, include=TRUE}
# explorative
fit.gamma <- fitdist(explorative_fixations$fixation_duration, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)
hist(explorative_fixations$fixation_duration, breaks=200)

# resting
fit.gamma <- fitdist(resting_fixations$fixation_duration, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)
hist(resting_fixations$fixation_duration, breaks=200)
```

The fit looks good. We will therefore use generalized linear modeling to fit a model on the gamma distributed fixation duration for exploring and resting fixations individually. We specify drift, input_noise, and level as fixed effects while assuming an interaction effect between drift and input_noise. 

First exploring fixations...
```{r fixation_duration_explore, include=TRUE}

fixDur_explore <- glmer(fixation_duration ~ drift*level_difficulty + input_noise + (1|ID),  data = explorative_fixations, family = Gamma)
summary(fixDur_explore)

#fixDur_explore.free_slope <- glmer(fixation_duration ~ drift*level_difficulty + input_noise + (1 + input_noise|ID),  #data = explorative_fixations, family = Gamma)
#summary(fixDur_explore.free_slope)

#coef(fixDur_explore)
#coef(fixDur_explore.free_slope). # when freeing slope for input noise, we can actually see single individuals skewing the coefficients for input noise

fixDur_explore <- glmer(fixation_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID),  data = explorative_fixations, family = Gamma)
summary(fixDur_explore)

```

Discussing the results: ...

Then for resting fixations...
```{r fixation_duration_rest, include=TRUE}

fixDur_rest <- glmer(fixation_duration ~ drift*level_difficulty + input_noise + (1|ID),  data = resting_fixations, family = Gamma)
summary(fixDur_rest)

# N_obs & N_drifts
fixDur_rest <- glmer(fixation_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID),  data = resting_fixations, family = Gamma)
summary(fixDur_rest)

```

Discussing the results: We find effects for drift (True vs. False) as well as both levels of level_difficulty. We find no effects for either one of input_noise:weak or input_noise:strong. We also find an interaction effect for level_difficulty(hard)*drift.

## fixation location

Next we will take a look at the fixation location in terms of y location (vertical position of eyes on screen). Fixation locations might actually be normally distributed. 
```{r check_fixloc, include=TRUE}
fit.gauss <- fitdist(data_fixations$converging_eye_y, distr = "norm", method = "mme")
summary(fit.gauss)
plot(fit.gauss)
hist(data_fixations$converging_eye_y, breaks=200)


```

That looks smooth. We will therefore be able to fit a LMM without having to specify a family for our outcome variable converging_eye_y. 
We stick to our fixed effects model structure and fit a model for exploring and resting fixations individually. First we will fit for exploring fixations.
```{r fixation_location_explore, include=TRUE}

fixloc_explore <- lmer(converging_eye_y ~ drift*level_difficulty + input_noise + (1|ID),  data = explorative_fixations, REML = FALSE)
summary(fixloc_explore)

# N_obs & N_drifts
fixloc_explore <- lmer(converging_eye_y ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID),  data = explorative_fixations, REML = FALSE)
summary(fixloc_explore)

```

Discussing the results: Hm we find no effects for both levels (weak and strong) of input noise. Weird! But then we find an effect for level_difficulty:hard, but not for medium (marginally significant); as well as interaction effects for drift and both levels of level_difficulty.

```{r fixation_location_rest, include=TRUE}

fixloc_rest <- lmer(converging_eye_y ~ drift*level_difficulty + input_noise + (1|ID),  data = resting_fixations, REML = FALSE)
summary(fixloc_rest)

# N_obs & N_drifts
fixloc_rest <- lmer(converging_eye_y ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID),  data = resting_fixations, REML = FALSE)
summary(fixloc_rest)

```

Discussing the results: Here nearly everything is significant. We only find no significant effect for input_noise:weak as well as the interaction effect of drift*level_difficulty:medium. FixLocY might therefore be a metric for input_noise (SoC) in case of string pertubations.

# Saccades

```{r filtering_saccades, include=TRUE}

# only considering fixations with duration > 0:
data_saccades <- data_saccades[data_saccades$saccade_amplitude > 0 & data_saccades$saccade_amplitude < 27, ]
# filter saccades that have no saccade amplitude
data_saccades <- data_saccades[!is.na(data_saccades$saccade_amplitude),]

# subsetting progressive saccades
progressive_saccades <- data_saccades[data_saccades$saccade_direction_y < 0, ]
# vs. regressive saccades going back to the spaceship
regressive_saccades <- data_saccades[data_saccades$saccade_direction_y > 0, ]

```

## saccade amplitude

```{r check_saccamp, include=TRUE}

fit.gamma <- fitdist(data_saccades$saccade_amplitude, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)

# sum(is.nan(data_saccades$saccade_amplitude))
hist(data_saccades$saccade_amplitude, breaks=200)
min(data_saccades$saccade_amplitude)
```

```{r saccade_amplitude_progress, include=TRUE}

# subsetting exploring fixations
saccamp_progress <- lmer(saccade_amplitude ~ drift*level_difficulty + input_noise + (1|ID),  data = progressive_saccades, REML = FALSE)
summary(saccamp_progress)

# N_obs & N_drifts
saccamp_progress <- lmer(saccade_amplitude ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID),  data = progressive_saccades, REML = FALSE)
summary(saccamp_progress)

```

```{r saccade_amplitude_regress, include=TRUE}

# vs. fixations resting in front of spaceship
saccamp_regress <- lmer(saccade_amplitude ~ drift*level_difficulty + input_noise + (1|ID),  data = regressive_saccades, REML = FALSE)
summary(saccamp_regress)

# N_obs & N_drifts
saccamp_regress <- lmer(saccade_amplitude ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID),  data = regressive_saccades, REML = FALSE)
summary(saccamp_regress)

```

Follow-up: Do saccades land nearer spaceship after saccade during strong input noise (compared to intercept)?

# Responses to SoC questionnaire after each trial
```{r soc, include=TRUE}

soc_data <- read_csv("soc_data/soc_data.csv")

soc_data <- soc_data %>%
  mutate(level_difficulty = case_when(
    (level == 1 | level == 2) ~ "easy",
    (level == 3 | level == 4) ~ "medium",
    (level == 5 | level == 6) ~ "hard",
    ))
soc_data$level_difficulty <- as.factor(soc_data$level_difficulty)
soc_data <- within(soc_data, level_difficulty <- relevel(level_difficulty, ref = "easy"))

hist(soc_data$SoC, breaks=7)
table(soc_data$SoC)

```

```{r soc_model, include=TRUE}

# fixed effects structure to be discussed:
# 1) done + drift*level_difficulty + input_noise
# 2) drift*level_difficulty + input_noise + (1|done)

soc_model <- lmer(SoC ~ done + drift*level_difficulty + input_noise + (1|ID),  data = soc_data, REML = FALSE)
summary(soc_model)
#coef(soc_model)
```

Discussing the results: ...

# Input data (input duration)
```{r input_data, include=TRUE}

input_data <- read_csv("input_data/input_data.csv")

# filtering
input_data <- input_data[input_data$input_duration > 0.033 & input_data$input_duration < 2.45, ]
input_data <- input_data %>% filter(!is.na(input_duration))

fit.gamma <- fitdist(input_data$input_duration, distr = "gamma", method = "mme")
summary(fit.gamma)
plot(fit.gamma)
hist(input_data$input_duration, breaks=200)

```

We will stick with the gamma dist.

```{r input_data_null, include=TRUE}

input_duration.null_fit <- glmer(input_duration ~ 1 + (1|ID),  data = input_data, family = Gamma)
summary(input_duration.null_fit)

```

## ICC for subject in inputduration
```{r data, include=TRUE}

ICC_input_dur <- 0.7201 / (0.7201 + 0.7758)
ICC_input_dur

```

ID explains a huge chunk of the variance in the input_duration data. We will therefore include it as random intercept effect.

```{r input_data_fit, include=TRUE}

input_duration.fit <- glmer(input_duration ~ N_visible_obstacles * N_visible_drift_tiles + input_noise + (1|ID),  data = input_data, family = Gamma)
summary(input_duration.fit)

```

Discussing the results: We find consistent effects for both our fixed effects. For each obstacle on screen the input duration decreases only a little bit, but still significantly. For every drift tile on screen however, the input duration decreases by a huge chunk. That is also due to there can only be a maximum of 2 drift tiles on screen (0 vs. 1 vs. 2), whereas obstacles vary largely (0 - 12?). For both levels of input noise, we find no significant difference to the intercept.
For Nobstacles, this may be due to simply there is less free space and thus the ways are shorter, resulting in shorter input. For Ndrift, this is more tricky. Do the players learn to incorporate drift into their action planning, resulting in shorter input solely due to using drift as 'passive' input.

We will isolate the effect solely for input noise in our next model:
```{r input_noise, include=TRUE}

input_duration.fit <- glmer(input_duration ~ input_noise + (1|ID),  data = input_data, family = Gamma)
summary(input_duration.fit)

```

Discussing the results: We find no effect of input_noise:weak for input_duration. However, if input_noise:strong is present, the input_duration increases! We would have thought different: the input_duration decreases to enable some kind of visual verification. Maybe humans do not rely so much on an ongoing regulatory process (visually matching with updated intended position) but more on an initially laid out plan.



